---
title: '877. Stone Game'
date: 2020-09-08 21:37:09
tags: 
    - DP
    - memorization
categories: Leetcode
---
<!--more -->
Alex and Lee play a game with piles of stones. There are an even number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`.

The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.

Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alex and Lee play optimally, return `True` if and only if Alex wins the game.
<!--more -->

**Example 1:**

``` txt
Input: piles = [5,3,4,5]
Output: true
Explanation:
Alex starts first, and can only take the first 5 or the last 5.
Say he takes the first 5, so that the row becomes [3, 4, 5].
If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.
If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alex, so we return true.
```

**Constraints:**

- `2 <= piles.length <= 500`
- `piles.length` is even.
- `1 <= piles[i] <= 500`
- `sum(piles)` is odd.

## 题目大意

a,b 两人从一数列中轮流取数，每次只能取数列两端点的数字，给定数列，问a的能否胜利。

## 思路和代码

因为是dp的分类里面找的，所以下意识就是用记忆化搜索了。`dp[i][j]` 表示序列剩余编号是从i到j时，分数的最大(对a）/最小（对b）值。可以这样表示是因为`(i - j) % 2 == 1`对应的是a，`(i - j) % 2 == 0`对应的是b，两人不会用到相同的`dp[i][j]`值，猜出来的转移方程差不多就是  
`dp[i][j] = total + max(dp[i + 1][j], dp[i][j - 1])` (对a)  
`dp[i][j] = total - max(dp[i + 1][j], dp[i][j - 1])`（对b）

代码如下：

``` java
class Solution {
    int dp[][];
    public boolean stoneGame(int[] piles) {
        dp = new int [piles.length][piles.length];
        return dfs(piles, 0, piles.length - 1, 0) > 0;
    }

    public int dfs(int[] piles, int start, int end, int total) {
        if(start == end) {
            return total;
        }
        if((start - end) % 2 == 1) {
            if(dp[start + 1][end] == 0) dp[start + 1][end] = dfs(piles, start + 1, end, total + piles[start]);
            if(dp[start][end - 1] == 0) dp[start][end - 1] = dfs(piles, start, end - 1, total + piles[end]);
            return total + Math.max(dp[start + 1][end], dp[start][end - 1]);
        } else {
            if(dp[start + 1][end] == 0) dp[start + 1][end] = dfs(piles, start + 1, end, total -piles[start]);
            if(dp[start][end - 1] == 0) dp[start][end - 1] = dfs(piles, start, end - 1, total - piles[end]);
            return total - Math.max(dp[start + 1][end], dp[start][end - 1]);
        }

    }

}
```

> 当然这题还有偷懒的数学方法，如果a刚开始选择的是奇数堆，因为剩下的只有偶数堆，所以b只能拿掉偶数的堆，那么这样下去a可以拿到所有的奇数堆，如果a刚开始选择偶数堆同理，总结下来就是a可以选择拿到石子中的一半或者另一半，而这两半总有一个会更大些，所以a，即先拿者，有必胜策略，程序只要`return true` 就AC了。
