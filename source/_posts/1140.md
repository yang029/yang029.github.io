---
title: '1140. Stone Game II'
date: 2020-09-09 19:06:23
tags: 
    - DP
    - memorization
categories: Leetcode
---
<!--more -->
Alex and Lee continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.

Alex and Lee take turns, with Alex starting first. Initially, `M = 1`.

On each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.

The game continues until all the stones have been taken.

Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get.
<!--more -->

**Example 1:**

``` txt
Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger.
```

**Constraints:**

- `1 <= piles.length <= 100`
- `1 <= piles[i] <= 10 ^ 4`

## 题目大意

a，b两人轮流从一数列里面取数，每次最多连续取 M * 2 个（M是之前最长连续取的数），求a能取到的最大和值。

## 思路与代码

显然还是一道dp，我还是直接上记忆化了，非常粗暴的就定义了dp[x][m][person] 表示的是取到第x个数字，M的值是m， person指的是轮到a还是b取

```java
class Solution {
    int[][][] dp;
    public int stoneGameII(int[] piles) {
        dp = new int[piles.length + 1][piles.length + 1][2];
        int sum = 0;
        for(int num : piles) {
            sum += num;
        }
        return dfs(piles, 0, 1, 0) + sum >> 1;
    }

    private int dfs(int[] piles, int pos, int m, int person) {
        if(pos >= piles.length) {
            return 0;
        }
        int ret = -10000000;
        if(person == 1) {
             if(dp[pos + 1][m][0] == 0) {
                dp[pos + 1][m][0] = dfs(piles, pos + 1, m, 0);
             }
             ret = dp[pos + 1][m][0] - piles[pos];
         }
        int sum = 0;
        for(int i = pos; i < piles.length && i < pos + 2 * m ; i++) {
            sum += piles[i];
            if(person == 0) {
                if(dp[i + 1][Math.max(m, i - pos + 1)][1] == 0)
                    dp[i + 1][Math.max(m, i - pos + 1)][1] = dfs(piles, i + 1, Math.max(m, i - pos + 1), 1);
                ret = Math.max(ret, dp[i + 1][Math.max(m, i - pos + 1)][1] + sum);
            } else {
                if(dp[i + 1][Math.max(m, i - pos + 1)][0] == 0)
                    dp[i + 1][Math.max(m, i - pos + 1)][0] = dfs(piles, i + 1, Math.max(m, i - pos + 1), 0);
                ret = Math.min(ret, dp[i + 1][Math.max(m, i - pos + 1)][0] - sum);
            }
        }
        return ret;
    }
}
```

后来发现还有更加简洁的version，其实每个人的目标都是相同的 -- 拿最多的， 所以分类并不是特别的必要。以及多了一些必要的优化，比如当剩下的 < 2 * m 的时候，就一口气全部拿走

``` java
    public int stoneGameII(int[] piles) {
        int[] presum =  Arrays.copyOf(piles, piles.length);
        for (int i = presum.length - 2; i >= 0; i--) presum[i] += presum[i + 1];
        return dfs(presum, 1, 0, new int[piles.length][piles.length]);
    }
    private int dfs(int[] presum, int m, int p, int[][] memo) {
        if (p + 2 * m >= presum.length) { // last player takes all
            return presum[p];
        }

        if (memo[p][m] > 0) return memo[p][m];
        int res = 0, take = 0;
        for (int i = 1; i <= 2 * m; i++) {
            // current take
            take = presum[p] - presum[p + i];
            // take max of current + what lefts from other player max take
            res = Math.max(res, take + presum[p + i] - dfs(presum, Math.max(i, m), p + i, memo));
        }
        memo[p][m] = res;
        return res;
    }
```
