---
title: '1022. Sum of Root To Leaf Binary Numbers'
date: 2020-09-08 20:44:34
categories: 
    - Leetcode
---
<!--more -->
Given a binary tree, each node has value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return the sum of these numbers.
<!--more -->

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png)

``` txt
Input: [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```

**Note:**

1. The number of nodes in the tree is between `1` and `1000`.
2. node.val is `0` or `1`.
3. The answer will not exceed `2^31 - 1`.

## 题目大意

大致意思就是有一个结点值为1或0的二叉树，要输出所有从根到叶节点的二进制路径之和。

## 思路和代码

我本来想的是遍历全树的时候顺便计算和，可是太蠢没想出来怎么计算，就直接暴力遍历全树然后记录下了所有路径，最后一遍求和。

``` java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        List<List<Integer>> ret = dfs(root);
        System.out.println(ret);
        int ans = 0;
        for(List<Integer> l : ret) {
            for(int i = 0; i < l.size(); i++) {
                ans += l.get(i) << i;
            }
        }
        return ans;
    }
    private List<List<Integer>> dfs(TreeNode root) {
        if(root == null) {
            return new ArrayList<>();
        }

        List<List<Integer>> ret = new ArrayList<>();
        ret.addAll(dfs(root.left));
        ret.addAll(dfs(root.right));
        if(ret.size() == 0) {
            ret.add(new ArrayList<>(Arrays.asList(root.val)));
            return ret;
        }
        for(List<Integer> l : ret) {
            l.add(root.val);
        }
        return ret;
    }
}
```

后来看了一眼讨论，发现自己蠢的可爱，十进制表示的数，乘以二不就是整体往左边移了一位嘛。那就dfs的时候从上往下每次都把结果*2 + 当前的值不就完了。

``` java
class Solution {
    public int sumRootToLeaf(TreeNode root) {
        return dfs(root, 0);
    }

    public int dfs(TreeNode root, int val) {
        if (root == null) return 0;
        val = val * 2 + root.val;
        return root.left == root.right ? val : dfs(root.left, val) + dfs(root.right, val);
    }
}
```
